# 고정밀 선택 컴포넌트 성능 최적화 계획

## 1. 성능 병목 분석 (Analysis)

### 1.1 과도한 DOM 노드 생성
- **원인**: `NumberInputSelector`에서 무게 선택 시 0kg부터 1000kg까지 0.5kg 단위로 배열을 생성하면 약 **2,001개**의 요소를 `map`으로 직접 렌더링함.
- **현상**: 저사양 기기 및 모바일 브라우저에서 메모리 점유율 급증, 스크롤 버벅임 발생.

### 1.2 불필요한 배열 및 객체 재생성
- **원인**: `NumberInputSelector` 컴포넌트가 부모의 상태 변화로 리렌더링될 때마다 수천 개의 숫자가 포함된 `values` 배열을 `for` 루프로 매번 다시 계산함.
- **현상**: CPU 자원 낭비 및 렌더링 지연.

### 1.3 잦은 상태 업데이트 (onChange)
- **원인**: `onScroll` 핸들러가 미세한 스크롤 단위마다 `onChange`를 호출하여 부모 컴포넌트(`WorkoutLog`)의 복잡한 폼 상태를 실시간으로 업데이트함.
- **현상**: 폼 전체 리렌더링으로 인한 입력 지연.

## 2. 공식 문서 기반 해결 방안 (Proposed Solutions)

### 2.1 리스트 가상화 (List Virtualization) 도입
- **참고**: [React 공식 문서 - 대량의 데이터 렌더링](https://react.dev/learn/render-lists#keeping-list-items-order-with-key)
- **방법**: 전체 2,000개 요소를 그리는 대신, 화면에 보이는 5~7개의 요소만 렌더링하고 나머지는 스크롤 위치에 따라 동적으로 교체.
- **도구**: 라이브러리 추가 없이 `CSS scroll-snap`과 결합된 **동적 윈도잉(Dynamic Windowing)** 로직 직접 구현.

### 2.2 메모이제이션 (Memoization) 최적화
- **참고**: [React Docs - useMemo](https://react.dev/reference/react/useMemo)
- **방법**: `values` 배열 생성을 `useMemo`로 감싸고 `min`, `max`, `step`이 변경될 때만 계산하도록 수정.

### 2.3 스크롤 핸들링 최적화
- **방법**: 
  - 스크롤 중에는 `onChange` 호출을 지연시키고, 스크롤이 완전히 멈춘 지점(`Snap End`)에서만 최종 값을 부모에게 전달.
  - `isInternalScroll` 플래그를 정교화하여 스크롤 이벤트와 외부 Prop 업데이트 간의 순환 참조(Loop) 완벽 차단.

### 2.4 GPU 가속 레이어 분리
- **방법**: 오버레이 그라데이션 및 선택 하이라이트 박스에 `will-change: transform`을 부여하여 브라우저의 합성 레이어(Compositing Layer) 활용.

## 3. 구현 세부 계획 (Implementation Steps)

1. **NumberInputSelector.tsx**: `values` 계산 로직에 `useMemo` 적용.
2. **VerticalScrollSelector.tsx**: 
   - 현재 인덱스 기반으로 앞뒤 10개만 렌더링하는 간이 가상화 적용 (또는 성능이 검증된 가로/세로 통합 가상화 로직 설계).
   - `onScroll` 내부에 `debounce` 또는 `Throttling` 개념 도입.
3. **WorkoutLog.tsx**: `BottomSheet` 내부의 선택기가 부모의 폼 상태를 실시간으로 건드리지 않도록 로컬 상태(Local State)에서 조작 후 '확인' 클릭 시점에 `setValue` 호출하도록 변경.

## 4. 기대 효과
- **DOM 노드 수**: 2,000개 -> 20개 내외 (99% 감소)
- **메모리 절감**: 모바일 환경 안정성 확보
- **UX**: 60fps의 부드러운 휠 스크롤 경험 제공
